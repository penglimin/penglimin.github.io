---
layout: post
title: 数据
date: 2014-03-1 15:32:24.000000000 +09:00
---

程序对数据进行操作，我们将对数据进行描述。描述他的各种类型，描述他的特点以及如何声明它。本章还将描述变量的三个属性---作用域、链接属性和存储属性。这三个属性决定了一个变量的可视性(也就是它可以在什么地方使用)和生命期(它的值将保持多久)

##1.基本数据类型
     
     C语言中，仅有4中基本数据类型  ---整型、浮点型、指针和聚合类型(数组和结构等)。
     所有其他类型都是从这4种基本数据类型的某种组合派生而来。
 
###1.1 整型家族
     
  整型家族包括`字符`、`短整型`、`整型`和`长整型`，他们都分为 `有符号` 和 `无符号`两种版本。
  
  注释：`长整型至少应该和整型一样长，而整型至少应该和短整型一样长。`
  
    整型字面值。
    如果一个多字符常量的前面有一个L那么它就是宽字符常量。
    枚举类型

###1.2 浮点类型
  浮点数家族包括float、double和long double类型。通常，这些类型分别提供单精度，双精度以及在某些支持扩展精度的机器上提供扩展精度。
  
###1.3 指针
  
      指针是C语言为什么如此流行的一个重要原因。指针可以有效地实现
      诸如tree和list这类高级数据结构，其他有些语言，如Pascal何Modula-2，
      也实现了指针，但他们不允许在指针上执行算数或比较操作，也不允许任何方式
      创建指向已经存在的数据对象的指针。正是由于不存在这方面的限制，所以，
      用C语言可以比使用其他语言编写出更为紧凑和有效的程序。同时，
      C对指针的使用的不加限制正是许多令人欲哭无泪和咬牙切齿的错误的根源。
  
     变量的值存储于计算机的内存中，每个变量都占据一个特定的位置，
     每个内存位置都由地址唯一确定并引用，就像一条街道上的房子由他们的
     门牌号码标识一样。指针只是地址的另一个名字罢了。指针变量就是一个其值为
     另一个内存地址的变量。C语言拥有一些操作符，你可以获得一个变量的地址，
     也可以通过一个指针变量取得它所指向的值或数据结构。
     
####指针常量：
 
    指针常量与非指针常量在本质上是不同的，因为编译器负责把变量赋值给计算机内存中的位置，
    程序员事先无法知道某个特定的变量将存储到内存中的哪个位置。因此你通过一个操作符获得
    一个变量的地址而不是直接把它的地址写成字面值常量的形式，例如，如果我们希望知道变量
    abc的地址，我们无法书写一个类似0xff24eecc这样的字面值，因为我们不知道这是不是编
    译器实际存放这个变量的内存位置。事实上，当一个函数每次被调用时，他的自动变量(局部变量)
    可能每次分配的内存位置都不相同。因此，把指针常量表达为数值字面值的形式几乎没有用处，
    所以C语言内部并没有特地定义这个概念。
####字符串常量：
       
    许多人对C语言不存在字符串类型感到奇怪，不过C语言提供了字符串常量。C语言存在字符串的概念：
    他就是一串以NUL字符结尾的零个或多个字符。字符串通常存储在字符数组中，这也是C语言没有
    显式的字符串类型的原因。之所以选择NUL作为字符串的终止符，是因为他不是一个可打印字符。
`K&R C:`
    
    在字符串常量的存储形式中，所有的字符和NUL终止符都存储于内存的某个位置，K&R C并没有
    提及一个字符串常量中的字符是否可以被程序修改，但它清楚地表明，具有相同的值的不同字符串  
    常量在内存中是分开存储的，因此，许多编译器都允许程序修改字符串常量。
    ANSI C则声明如果对一个字符串常量进行修改，其效果是未定义的，他也不允许编译器   
    把一个字符串常量存储在一个地方，即使他在程序中多次出现。这就是使得修改字符串常量   
    变得极其危险，因为对一个常量进行修改可能殃及程序中其他字符串常量。因此，    
    许多ANSI编译器不允许修改字符串常量，或者提供编译选项，让你自行选择是否允许   
    修改字符串常量。在实践中，请尽量不要这么做，如果你需要修改字符串，请把它存储于数组中。
    
##2.声明：由于声明比较简单，这里不再描述

-----------------------------------------------

##3.typedef

你因该使用typedef而不是#define来创建新的类型名，因为后者无法正确的处理指针类型。
  
      例如：
      #define d_ptr_to_char   char *
      d_ptr_to_char   a, b;
      
      正确的声明了a， 但是b却被声明为一个字符。在定义更为复杂的类型名字时，如函数指针
      或指向数组的指针，使用typedef更为合适。
      
##4.常量  
ANSI C允许你声明常量，常量的样子和变量完全一样，只是他们的值不能修改，你可以使用const关键字来声明常量，如下面的例子：
     
     int     const     a;
     const   int       a;
     
     这两条语句都把a声明为一个整数，它的值不能被修改。
当涉及到指针变量时，情况就变得更加有趣，因为有两样东西都有可能成为常量----指针变量和它所指向的实体。下面有几个声明的例子。

      int   *pi;    
      pi 是一个普通的指向整型的指针。而变量
      int  const   *pci;
      则是一个指向整型常量的指针，你可以修改指针的值，但你不能修改它所指向的值。相比之下：
      int     *   const   pci;
      则声明pci为一个指向整型的常量指针，此时指针是常量，他的值无法修改，但你可以修改
      它所指向的整型的值。
      int    const *   const   cpci;

     最后，在cpci这个例子里，无论是指针本身还是它所指向的值都是常量，不允许修改。
`Action！！！`：
     
     当你声明变量时，如果变量的值不会被修改，你应当在声明中使用const关键字，
     这种做法不仅使你的意图在其他阅读你的程序的人面前得到更清晰的展现，
     而且当这个值被意外修改时，编译器能够发现这个问题。
         
##5.作用域  

       当变量在程序的某个部分被声明时，他只有在程序的一定区域才能被访问。
       编译器可以确认4种不同类型的作用域
       文件作用域
       函数作用域
       代码块作用域
       原型作用域
       
       标识符声明的位置决定他的作用域。
  1.代码块作用域
       
        位于一对花括号之间的所有语句称为一个代码块。任何在代码块的开始位置声明的标识符都具有代码块作用域(block scope),表示它们可以被这个代码块中的所有语句访问。
  2.文件作用域
  
      任何在多有代码块之外声明的标识符都具有文件作用域(file scope),它表示这些标识符从它们的声明之处直到它所在的源文件结尾处都是可以访问的。在文件中定义的函数名也具有文件作用域，因为函数名本身并不属于任何代码块。应该说明的是，在头文件中编写并通过#include指令包含到其他文件中的声明就好像他们是直接写在那些文件中一样，他们的作用域并不局限于头文件的文件尾。
  
  3.原型作用域
      
      原型作用域(prototype scope)只适用于在函数原型中声明的参数名，在原型中(与函数的定义不同)，参数的名字并非必须，但是，如果出现参数名，你可以随你所愿给他们取名字，他们不必与函数定义中的形参名匹配，也不必与函数实际调用时所传递的实参匹配。原型作用域防止这些参数名与程序其他部分的名字冲突。事实上，唯一可能出现的冲突就是在同一个原型中不止一次的使用同一个名字。
  
  4.函数作用域
      
      最后一种作用域的类型是函数作用域(function scope).它只适用于语句标签，语句标签用于goto语句。基本上，函数作用域可以简化为一条规则---------一个函数中的所有语句标签必须唯一。
  

##链接属性
当组成一个程序的各个源文件分别被编译之后，所有的目标文件以及那些从一个或多个文件函数库中引用的函数链接在一起，形成可执行程序。然而，如果相同的标识符出现在不同的几个源文件中时，`标识符属性`决定如何处理在不同文件中出现的标识符。标识符的作用域与它的链接属性有关，但这两个属性并不相同。

链接属性一共有3种： 
       
       external(外部)
       internal(内部)
       none(无)
       
       没有链接属性的标识符(none)总是被当做单独的个体，也就是说该标识符的多个声明呗当做独立不同的实体。属于internal链接属性的标识符在同一个源文件内的所有声明中都指同一个实体，但位于不同源文件的多个声明则分属不同的实体。最后，属于externa链接属性的标识符不论声明多少次，位于几个源文件都表示同一个实体。
       
       typedef  char *a;
       int  b;
       int c(int d)
       {
       				int e;
       				int f(int g);
       }
       
       
       关键字extern和static用于在声明中修改标识符的链接属性。如果某个声明在正常情况下具有external链接属性，在他前面加上static关键字可以使他的链接属性变为internal。例如，代码中第二个声明像下面这样写：
       static int b;
       那么变量b将为这个源文件所私有。在其他源文件中，如果也链接一个叫做b的变量，那么他所引用的是另一个不同的变量，类似，你也可以把函数声明为static，如下：
       static int c(int d)
       这样可以防止他被其他源文件调用。
       
       static只对缺省链接属性为external的声明才有改变链接属性的效果。例如，尽管你可以在声明 int e前加上static关键字，但他的效果完全不一样。因为e的缺省链接属性并不是external。
       
       extern关键字的规则更为复杂。一般而言，他为一个标识符指定external链接属性，这样就可以访问在其他任何位置定义的实体。例如下面 为k 指定external链接属性，这样一来，函数就可以访问在其他文件声明的外部变量了。
       
       
	 static  int i;
	 int  func()
	 {
		 int  j;
		 extern int k;
		  extern int i;
	 
	 }

