## 策略模式

”组件协作“ 模式

现代软件专业分工之后的第一个结果是“框架和应用程序的划分”，”组件协作“ 模式 通过 晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时，常用的模式。

典型模式：

模板方法  （Template Method）

策略模式 （Strategy）

观察者模式（Observe/Event）



### 动机

在软件构建过程中。某些对象使用的算法可能多种多样，经常变化，如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担。



如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？？？



场景：

比如：国际电商。不同国家税法算法不同。



伪代码1：

```c++
enum TaxBase{
	CN_Tax,
	US_Tax,
	DE_Tax
};
class SalesOrder{
  TaxBase tax;
public:
  double CalculateTax(){
    if(tax == CN_Tax){
      // CN 算法
    }else if(tax == US_Tax){
      // US 算法
    }else if(tax == DE_Tax){
      // DE 算法
    };
  };
};
```

上述代码，初看，没有什么不合适。

1. 不要静态的看一个软件设计，而是要动态的看。作为程序员要有一个时间轴的概念。
2. 未来可能支持 日本，法国，韩国的税法算法。
3. 支持 法国 税法，怎么做？？？ 加枚举，加   if ….  else ….



那样就违背了：开闭原则。对扩展开放，对修改关闭。

我们可以利用扩展面对未来的变化，而不是通过改源代码的方法面对未来的变化。



```c++
class TaxStrategy{ // 税法策略基类
public：
  virtual double Calculate(const Context& context) = 0;
  virtual ~TaxStrategy(){};
};

class CNTax:public TaxStrategy{
public：  
  virtual double Calculate(const Context& context)
  {
    // 算法
  }
}；

class USTax:public TaxStrategy{
public：  
  virtual double Calculate(const Context& context)
  {
    // 算法
  }
}；
  
class DETax:public TaxStrategy{
public：  
  virtual double Calculate(const Context& context)
  {
    // 算法
  }
}；
  
  
  
class SalesOrder{
private:
  TaxStrategy *strategy; // 多态指针
public：  
  SalesOrder(StrategyFactory *strategyFactory)
  {
    this->strategy = strategyFactory->NewStrategy();
  }
  ~ SalesOrder(){
    delete this->strategy;
  }
  public double CalculateTax(){
    Context context();
    double val = strategy->Calculate(context); // 多态调用
  };
}；

```



增加 法国 业务，扩展一个法国算法 策略类 即可。

遵守了 开闭原则，易复用。



注意：

我们这里说 面向对象，设计模式的复用，是编译单位的复用。二进制层面的复用性。

真正的复用是编码之后，编译之后，测试之后，部署之后。就不再改变了。 片段式的代码复用，是拷贝粘贴不是复用。



### 模式定义

定义一系列算法，把它们一个个封装起来。并且使它们可互相替换（变化）。该模式使得算法  可独立于 使用它的客户程序（稳定）而变化（扩展，子类化）。 ——————————《设计模式》GoF



### 结构

![strategy](https://penglimin.github.io/assets/LeonpengPicture/DesignPattern/Strategy/strategy.png)





   





