## 策略模式

”组件协作“ 模式

现代软件专业分工之后的第一个结果是“框架和应用程序的划分”，”组件协作“ 模式 通过 晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时，常用的模式。

典型模式：

模板方法  （Template Method）

策略模式 （Strategy）

观察者模式（Observe/Event）



### 动机

在软件构建过程中。某些对象使用的算法可能多种多样，经常变化，如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担。



如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？？？



场景：

比如：国际电商。不同国家税法算法不同。



伪代码1：

```c++
enum TaxBase{
	CN_Tax,
	US_Tax,
	DE_Tax
};
class SalesOrder{
  TaxBase tax;
public:
  double CalculateTax(){
    if(tax == CN_Tax){
      // CN 算法
    }else if(tax == US_Tax){
      // US 算法
    }else if(tax == DE_Tax){
      // DE 算法
    };
  };
};
```

上述代码，初看，没有什么不合适。

1. 不要静态的看一个软件设计，而是要动态的看。作为程序员要有一个时间轴的概念。
2. 未来可能支持 日本，法国，韩国的税法算法。
3. 支持 法国 税法，怎么做？？？ 加枚举，加   if ….  else ….



那样就违背了：开闭原则。对扩展开放，对修改关闭。

我们可以利用扩展面对未来的变化，而不是通过改源代码的方法面对未来的变化。



```c++
class TaxStrategy{ // 税法策略基类
public：
  virtual double Calculate(const Context& context) = 0;
  virtual ~TaxStrategy(){};
};

class CNTax:public TaxStrategy{
public：  
  virtual double Calculate(const Context& context)
  {
    // 算法
  }
}；

class USTax:public TaxStrategy{
public：  
  virtual double Calculate(const Context& context)
  {
    // 算法
  }
}；
  
class DETax:public TaxStrategy{
public：  
  virtual double Calculate(const Context& context)
  {
    // 算法
  }
}；
  
  
  
class SalesOrder{
private:
  TaxStrategy *strategy; // 多态指针
public：  
  SalesOrder(StrategyFactory *strategyFactory)
  {
    this->strategy = strategyFactory->NewStrategy();
  }
  ~ SalesOrder(){
    delete this->strategy;
  }
  public double CalculateTax(){
    Context context();
    double val = strategy->Calculate(context); // 多态调用
  };
}；

```



增加 法国 业务，扩展一个法国算法 策略类 即可。

遵守了 开闭原则，易复用。



注意：

我们这里说 面向对象，设计模式的复用，是编译单位的复用。二进制层面的复用性。

真正的复用是编码之后，编译之后，测试之后，部署之后。就不再改变了。 片段式的代码复用，是拷贝粘贴不是复用。



### 模式定义

定义一系列算法，把它们一个个封装起来。并且使它们可互相替换（变化）。该模式使得算法  可独立于 使用它的客户程序（稳定）而变化（扩展，子类化）。 ——————————《设计模式》GoF



### 结构

![strategy](https://penglimin.github.io/assets/LeonpengPicture/DesignPattern/Strategy/strategy.png)



在策略模式结构图中包含如下几个角色：
● Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时 可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策 略。
● Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可 以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具 体策略类中实现的算法。
● ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策 略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。



策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责 任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系 列具体策略类里面，作为抽象策略类的子类。在策略模式中，对环境类和抽象策略类的理解 非常重要，环境类是需要使用算法的类。在一个系统中可以存在多个环境类，它们可能需要 重用一些相同的算法。



###  要点总结

1. Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在 运行时 （传入一个多态对象，支持多态调用）方便地根据需要在各个算法之间进行切换。
2. Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句就是在解耦合。含有许多条件判断语句的代码通常都需要 Strategy模式。      判断语句是 Strategy 模型可以出现的特殊标志。

​       if else 是结构化时代的一种 分而治之的思维。可以用面向对象的抽象解决。



什么时候出现 if  else 不需要考虑策略模式？？？    if else 是绝对不变的，比如性别判断。。。比如 一周七天的判断。

业务场景变化是非常迅速的，常常是过一段时间加一种情况。这种情景特别要小心。看到if  else  就相当于在代码中闻到了坏味道。

80%-90%的 if else可以适用  策略模式。



如果程序安装在中国使用。

if(中国税法){

}else if(美国){

}else if(德国){

}else if (...){

}

中国条件后边的代码，肯定是不会被使用的，有很大一部分代码是装载进代码段中的，但是却不被使用。

有可能会占用cpu高速缓存。主存。其他代码，被迫挤出 主存，cpu高速缓存。



3. 如果Strategy 对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。   Strategy可以设置为单例



主要优点：

1. 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法 或行为，也可以灵活地增加新的算法或行为。
2. 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族， 恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。
3. 使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种 算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding) 在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。
4. 策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不 同的环境类可以方便地复用这些策略类。



主要缺点:

1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理 解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有 的算法或行为的情况。
2. 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的 具体策略类。
3. 无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用 一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的 情况。



适用场景:

在以下情况下可以考虑使用策略模式：

1. 一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算 法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一 的接口，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法 类，并只需要维持一个数据类型是抽象算法类的对象。
2. 一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来 实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难 以维护的多重条件选择语句。
3. 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数 据结构，可以提高算法的保密性与安全性。



